from apps.users.models import User
from apps.utils.messages import JWTErrorMessages
from apps.api_exceptions import (
    ResourceNotFoundAPIError,
    NotAuthenticatedAPIError,
    JWTAPIError,
)
from tests.factory import JWTFactory, UserFactory
from tests.utils import empty_queryset
from rest_framework.fields import CharField
from rest_framework import status
from django.test import Client
from django.urls import reverse
from unittest.mock import Mock, patch
from typing import Dict
import pytest


# This constant is used when the serializer error messages are the default.
DEFAULT_ERROR_MESSAGES = CharField().error_messages


@pytest.mark.django_db
class TestLogoutAPIView:
    """
    This class encapsulates all the tests of the view responsible for handling a
    user's logout requests.

    A successful logout will consist of invalidating the last JSON Web Tokens
    generated by the user, adding them to a blacklist if they have not yet expired, to
    prevent their further use.

    #### Clarifications:

    - The execution of this logic does not depend on the user role associated with the
    JSON Web Tokens. However, to simplify testing, the `seacher` role is used for
    users.
    - The execution of this logic does not depend on the user's permissions; that is,
    the user's permissions are not validated.
    """

    path = reverse(viewname="jwt_logout_user")
    user_factory = UserFactory
    jwt_factory = JWTFactory
    client = Client()

    def test_if_access_token_not_provided(self) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the access token is not provided.
        """

        # Creating the JWTs to be used in the test
        user, _, _ = self.user_factory.searcher_user(
            active=True, save=True, add_perm=False
        )
        refresh_token = self.jwt_factory.refresh(
            role_user=user.content_type.model,
            user=user,
            exp=False,
            save=True,
        ).get("token")

        # Simulating the request
        response = self.client.post(
            path=self.path,
            data={"refresh_token": refresh_token},
            content_type="application/json",
        )

        # Asserting that response data is correct
        status_code_expected = NotAuthenticatedAPIError.status_code
        code_expected = NotAuthenticatedAPIError.default_code
        message_expected = NotAuthenticatedAPIError.default_detail

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == message_expected

    def test_if_valid_data(self) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the request data is valid.
        """

        # Creating the JWTs to be used in the test
        user, _, _ = self.user_factory.searcher_user(
            active=True, save=True, add_perm=False
        )
        jwt_data = self.jwt_factory.access_and_refresh(
            role_user=user.content_type.model,
            user=user,
            exp_access=False,
            exp_refresh=False,
            save=True,
        )

        # Simulating the request
        response = self.client.post(
            path=self.path,
            data={"refresh_token": jwt_data["tokens"]["refresh_token"]},
            content_type="application/json",
            HTTP_AUTHORIZATION=f'Bearer {jwt_data["tokens"]["access_token"]}',
        )

        # Asserting that response data is correct
        assert response.status_code == status.HTTP_200_OK

    def test_if_empty_data(self) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the request data is empty.
        """

        error_messages_expected = {
            "refresh_token": [DEFAULT_ERROR_MESSAGES["required"]],
        }

        # Creating the JWTs to be used in the test
        user, _, _ = self.user_factory.searcher_user(
            active=True, save=True, add_perm=False
        )
        access_token = self.jwt_factory.access(
            role_user=user.content_type.model,
            user=user,
            exp=False,
            save=True,
        ).get("token")

        # Simulating the request
        response = self.client.post(
            path=self.path,
            data={},
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {access_token}",
        )

        # Asserting that response data is correct
        assert response.status_code == status.HTTP_400_BAD_REQUEST
        assert response.data["code"] == "invalid_request_data"

        # Asserting that the error messages are correct
        response_errors_formated = {
            field: [str(error) for error in errors]
            for field, errors in response.data["detail"].items()
        }

        for field, message in error_messages_expected.items():
            assert response_errors_formated[field] == message

    @pytest.mark.parametrize(
        argnames="data, error_message",
        argvalues=[
            (
                {
                    "refresh_token": JWTFactory.refresh_invalid(),
                },
                JWTErrorMessages.INVALID_OR_EXPIRED.value.format(
                    token_type="refresh"
                ),
            ),
            (
                {
                    "refresh_token": JWTFactory.refresh(
                        exp=True, save=False
                    ).get("token"),
                },
                JWTErrorMessages.INVALID_OR_EXPIRED.value.format(
                    token_type="refresh"
                ),
            ),
            (
                {
                    "refresh_token": JWTFactory.refresh(
                        exp=False, save=False
                    ).get("token"),
                },
                JWTErrorMessages.USER_NOT_MATCH.value,
            ),
        ],
        ids=[
            "refresh_token_invalid",
            "refresh_token_expired",
            "user_not_match",
        ],
    )
    def test_if_token_validation_failed(
        self,
        data: Dict[str, str],
        error_message: str,
    ) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the JWTs are invalid or expired.
        """

        # Creating the JWTs to be used in the test
        user, _, _ = self.user_factory.searcher_user(
            active=True, save=True, add_perm=False
        )
        access_token = self.jwt_factory.access(
            role_user=user.content_type.model,
            user=user,
            exp=False,
            save=True,
        ).get("token")

        # Simulating the request
        response = self.client.post(
            path=self.path,
            data=data,
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {access_token}",
        )

        # Asserting that response data is correct
        status_code_expected = JWTAPIError.status_code
        code_expected = JWTAPIError.default_code

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == error_message

    @pytest.mark.parametrize(
        argnames="access_blacklist, refresh_blacklist, error_message",
        argvalues=[
            (
                True,
                False,
                JWTErrorMessages.BLACKLISTED.value.format(token_type="access"),
            ),
            (
                False,
                True,
                JWTErrorMessages.BLACKLISTED.value.format(token_type="refresh"),
            ),
        ],
        ids=[
            "access_token_blacklisted",
            "refresh_token_blacklisted",
        ],
    )
    def test_if_token_blacklisted(
        self,
        access_blacklist: bool,
        refresh_blacklist: bool,
        error_message: str,
    ) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the JWTs are blacklisted.
        """

        # Creating the JWTs to be used in the test
        user, _, _ = self.user_factory.searcher_user(
            active=True, save=True, add_perm=False
        )
        access_token = self.jwt_factory.access(
            role_user=user.content_type.model,
            add_blacklist=access_blacklist,
            user=user,
            exp=False,
            save=True,
        ).get("token")
        refresh_token = self.jwt_factory.refresh(
            role_user=user.content_type.model,
            add_blacklist=refresh_blacklist,
            user=user,
            exp=False,
            save=True,
        ).get("token")

        # Simulating the request
        response = self.client.post(
            path=self.path,
            data={"refresh_token": refresh_token},
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {access_token}",
        )

        # Asserting that response data is correct
        status_code_expected = JWTAPIError.status_code
        code_expected = JWTAPIError.default_code

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == error_message

    def test_if_user_not_match(self) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the user does not match the JWT data.
        """

        # Creating the JWTs to be used in the test
        user, _, _ = self.user_factory.searcher_user(
            active=True, save=True, add_perm=False
        )
        access_token = self.jwt_factory.access(
            role_user=user.content_type.model,
            user=user,
            exp=False,
            save=True,
        ).get("token")
        refresh_token = self.jwt_factory.refresh(
            exp=False, save=False  # fmt: off
        ).get("token")

        # Simulating the request
        response = self.client.post(
            path=self.path,
            data={"refresh_token": refresh_token},
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {access_token}",
        )

        # Asserting that response data is correct
        status_code_expected = JWTAPIError.status_code
        code_expected = JWTAPIError.default_code
        response_data_expected = JWTErrorMessages.USER_NOT_MATCH.value

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == response_data_expected
